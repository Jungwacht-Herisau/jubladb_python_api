# DO NOT EDIT THIS FILE, it is auto-generated!
from jubladb_api.core import base_client
import typing
import datetime

from jubladb_api.generated.entities.keys import *
from jubladb_api.core.base_entity import BaseEntity

{% for entity in entities %}
from jubladb_api.generated.entities.{{ entity.name_singular }} import {{ entity.name_singular | snake_case_to_pascal_case }}
{% endfor %}

# @formatter:off

{% for entity in entities %}
{% with class_name=entity.name_singular|snake_case_to_pascal_case %}
{% if entity.allowed_operations|length > 0 %}
{% if entity.includeable|length > 0 %}
_{{ class_name }}_Include = typing.Literal[
{% for inc in entity.includeable %}
    "{{ inc }}",
{% endfor %}]
{% endif %}
{% if entity|entity_has_sortable_attributes > 0 %}
_{{ class_name }}_Sort = typing.Literal[
{% for attr in entity.attributes %}
{% if attr.sortable %}
    "{{ attr.name }}_asc",
{% endif %}
{% endfor %}
{% for attr in entity.attributes %}
{% if attr.sortable %}
    "{{ attr.name }}_desc",
{% endif %}
{% endfor %}
]
{% endif %}
{% endif %}
{% endwith %}
{% endfor %}


class Client(base_client.BaseClient):

    def __init__(self, url: str, api_key: str):
        super().__init__(url, {"{{ api_key_header }}": api_key})

    {% for entity in entities %}
    {% with class_name=entity.name_singular|snake_case_to_pascal_case %}
    {% for op in entity.allowed_operations %}
    {% if op.name == "GetList" %}
    def get_{{ entity.name_plural }}_list(self,
                            {% if entity.includeable|length > 0 %}
                            include: list[_{{ class_name }}_Include]|typing.Literal["*"]|None = None,
                            {% endif %}
                            {% if entity|entity_has_sortable_attributes %}
                            sort: list[_{{ class_name }}_Sort]|None = None,
                            {% endif %}
                            {% for attr in entity.attributes %}
                            {% for ft in attr.filter_types %}
                            filter_{{ attr.filter_name }}_{{ ft }}: {{ attr.type_|attribute_type_to_python_type }}|list[{{ attr.type_|attribute_type_to_python_type }}]|None = None,
                            {% endfor %}
                            {% endfor %}
                            ) -> list[{{ class_name }}]:
        {% if entity.includeable|length > 0 %}
        if include is None:
            include = []
        if include == "*":
            include = [
                {% for rel in entity.relations %}
                "{{ rel.relation_name }}",
                {% endfor %}
            ]
        {% endif %}
        filters = [
            {% for attr in entity.attributes %}
            {% for ft in attr.filter_types %}
            ("{{ attr.filter_name }}", "{{ ft }}", filter_{{ attr.filter_name }}_{{ ft }}),
            {% endfor %}
            {% endfor %}
        ]
        filters = [f for f in filters if f[2] is not None]
        json_response = self._request_list(
            "{{ entity.name_singular }}",

            {% if entity|entity_has_sortable_attributes %}
            sort,
            {% else %}
            [],
            {% endif %}

            {% if entity.includeable|length > 0 %}
            include,
            {% else %}
            [],
            {% endif %}

            filters)

        response_entities = []
        for data_obj in json_response["data"]:
            re = {{ class_name }}.from_json(data_obj)
            self._cache_add(re)
            response_entities.append(re)
        {% if entity.relations|length > 0 %}
        self._add_included_of_{{ entity.name_plural }}_to_cache(json_response)
        {% endif %}
        return response_entities
    {% endif %}
    {% if op.name == "GetSingle" %}
    def get_{{ entity.name_singular }}(self,
            id_or_key: int|{{ class_name }}Key,
            {% if entity.includeable|length > 0 %}
            include: list[_{{ class_name }}_Include]|typing.Literal["*"]|None = None,
            {% endif %}
                    ) -> {{ class_name }}:
        if isinstance(id_or_key, int):
            id_ = id_or_key
            entity_key = {{ class_name }}Key(id_)
        else:
            id_ = id_or_key.id
            entity_key = id_or_key
        {% if entity.includeable|length > 0 %}
        all_includes = [
                {% for rel in entity.relations %}
                "{{ rel.relation_name }}",
                {% endfor %}
            ]
        if include is None:
            include = []
        if include == "*":
            include = all_includes
        {% endif %}
        cached_entity = self._cache_get(entity_key)
        if cached_entity is not None:
            {% if entity.includeable|length > 0 %}
            cached_relations = [rel for rel in all_includes if cached_entity.is_relation_loaded(rel)]
            if all(rel in cached_relations for rel in include):
                return cached_entity
            else:
                include.extend(cached_relations)
            {% else %}
            return cached_entity
            {% endif %}

        json_response = self._request_single_get("{{ entity.name_singular }}",
                                                 id_,
                                                 {% if entity.includeable|length > 0 %}include,{% endif %}
                                                 )
        response_entity = {{ class_name }}.from_json(json_response["data"])
        if response_entity.key != entity_key:
            raise ValueError("Entity key mismatch")
        self._cache_add(response_entity)
        {% if entity.relations|length > 0 %}
        self._add_included_of_{{ entity.name_plural }}_to_cache(json_response)
        {% endif %}
        return response_entity
    {% endif %}
    {% endfor %}
    {% if entity.allowed_operations|length == 0 %}
    def get_{{ entity.name_singular }}(self,
            id_or_key: int|{{ class_name }}Key,
                    ) -> {{ class_name }}:
        if isinstance(id_or_key, int):
            id_ = id_or_key
            entity_key = {{ class_name }}Key(id_)
        else:
            id_ = id_or_key.id
            entity_key = id_or_key
        cached_entity = self._cache_get(entity_key)
        if cached_entity is not None:
            return cached_entity
        raise ValueError(f"no object known for {entity_key}. Entities of type {{ entity.name_singular }} can only be retrieved by including them while requesting other entities.")
    {% endif %}
    {% if entity.relations|length > 0 %}
    def _add_included_of_{{ entity.name_plural }}_to_cache(self, json_response: dict) -> None:
        for incl_data in json_response.get("included", []):
            {% for rel in entity.relations %}{% if loop.first %}if{% else %}elif{% endif %} incl_data["type"] == "{{ rel.related_type_plural }}":
                self._cache_add({{ rel.related_type_singular|snake_case_to_pascal_case }}.from_json(incl_data))
            {% endfor %}
    {% endif %}
    {% endwith %}
    {% endfor %}
# @formatter:on
